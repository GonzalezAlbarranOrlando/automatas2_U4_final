/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package automatas2_u4_final;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.Stack;
import java.util.StringTokenizer;

/**
 * 
 *
 * @author Salinas
 */
public class VentanaU3_01 extends javax.swing.JFrame {

    static String separadoresAux = "(){}<>+-*/=;|&,", opArit = "*/+-", opRel = "<>", opLog = "|&";
    static int contEtiq = 0;
    static int ev, ef, es, ei;
    static String codigoI = "";
    static String tablaC = "";
    static String tablaBloques = "";
    static int numTemp = 0;
    static int indexArrays = 0;

    static String[] arrTemp = new String[100];
    static String[] arrOp1 = new String[100];
    static String[] arrOp2 = new String[100];
    static String[] arrOp = new String[100];

    static String textoInterfaz = "";

    static String[] lineas;

    static int contMsg = 0;
    static String encabezado = "TITLE codigo prueba\n"
            + ".MODEL SMALL\n"
            + ".STACK 64\n";
    static String data = ".data\n";
    static String code = "\n.code\n"
            + "mov ax, @data\n"
            + "mov ds,ax\n\n";
    static String codigoE;

    public VentanaU3_01() {
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane2 = new javax.swing.JScrollPane();
        txtResultado2 = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        txt = new javax.swing.JTextArea();
        limpiarBtn = new javax.swing.JButton();
        procesarBtn = new javax.swing.JButton();
        abrirBtn = new javax.swing.JButton();
        guardarBtn = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtResultado1 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        txtResultado2.setColumns(20);
        txtResultado2.setRows(5);
        jScrollPane2.setViewportView(txtResultado2);

        txt.setColumns(20);
        txt.setRows(5);
        jScrollPane3.setViewportView(txt);

        limpiarBtn.setText("LIMPIAR");
        limpiarBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                limpiarBtnActionPerformed(evt);
            }
        });

        procesarBtn.setText("PROCESAR");
        procesarBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                procesarBtnActionPerformed(evt);
            }
        });

        abrirBtn.setText("ABRIR");
        abrirBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                abrirBtnActionPerformed(evt);
            }
        });

        guardarBtn.setText("GUARDAR");
        guardarBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                guardarBtnActionPerformed(evt);
            }
        });

        txtResultado1.setColumns(20);
        txtResultado1.setRows(5);
        jScrollPane4.setViewportView(txtResultado1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(abrirBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(20, 20, 20)
                        .addComponent(guardarBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(20, 20, 20)
                        .addComponent(limpiarBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(20, 20, 20)
                        .addComponent(procesarBtn))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 328, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 250, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 357, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane2)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 283, Short.MAX_VALUE)
                    .addComponent(jScrollPane4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 283, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(abrirBtn)
                    .addComponent(guardarBtn)
                    .addComponent(procesarBtn)
                    .addComponent(limpiarBtn))
                .addGap(20, 20, 20))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void abrirBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_abrirBtnActionPerformed
        txt.setText(abrirArchivo());
    }//GEN-LAST:event_abrirBtnActionPerformed

    private void guardarBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_guardarBtnActionPerformed
        guardarArchivo(txt.getText());
    }//GEN-LAST:event_guardarBtnActionPerformed

    private void limpiarBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_limpiarBtnActionPerformed
        txtResultado2.setText("");
        txtResultado1.setText("");
        txt.setText("");
        codigoI = "";
        tablaC = "";
        contEtiq = 0;
        numTemp = 0;

    }//GEN-LAST:event_limpiarBtnActionPerformed

    private void procesarBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_procesarBtnActionPerformed

        String cadenaInicial = txt.getText();

        System.out.println("\n\n\nCodigo fuente: \n" + cadenaInicial + "\n");
        cadenaInicial = juntarLineas(cadenaInicial);
        System.out.println("\n\n\nCodigo fuente: \n" + cadenaInicial + "\n");
        sent(cadenaInicial);

        System.out.println("Codigo intermedio: \n" + codigoI + "\n");
        System.out.println("Tabla de Cuadruples: \n" + tablaC + "\n");
        txtResultado1.setText(codigoI);
        tablaFinal();
        bloques(tablaBloques);//separar por bloques
        txtResultado2.setText(textoInterfaz);
        
        System.out.println(textoInterfaz);
        
        String[][] m=tabla_to_mat1(textoInterfaz);
        codigoEnsamblador(m);
        codigoE=encabezado+data+code+".exit\nend";
        System.out.println(codigoE);
        
        

    }//GEN-LAST:event_procesarBtnActionPerformed

    
    
    
        static void codigoEnsamblador(String[][]m){
        for (int i = 0; i < m.length; i++) {
            if (m[i][2].contains("+")) { 
                suma(m[i][0],m[i][1],m[i][3]);
            }else if (m[i][2].contains("-")) { 
                resta(m[i][0],m[i][1],m[i][3]);
            }else if (m[i][2].contains("*")) { 
                mul(m[i][0],m[i][1],m[i][3]);
            }else if (m[i][2].contains("/")) { 
                div(m[i][0],m[i][1],m[i][3]);
            }else if (m[i][2].contains("<")||m[i][2].contains(">")) { 
                condicion(m[i][0],m[i][1],m[i][2],m[i][3]);                                                            
            }else if(m[i][3].contains("READ")){ //READ A
                read(m[i][0]);
            }else if(m[i][3].contains("WRITE")){ //WRITE A || WRITE 'DAME EL PRIMER VALOR DE C:'
                if (m[i][0].contains("'")) {  //WRITE 'DAME EL PRIMER VALOR DE C:'
                    
                    writeMsg(asignacionDataMsg(m[i][0]));                     
                }else{//WRITE A 
                    writeVar(m[i][0]);                     
                }
            }                                                      
            else if(m[i][3].contains(":")){ //10: 
                code+="e"+m[i][3]+"\n\n";
            }else if(validacionNum(m[i][3])){ //goto 10
                code+="jmp e"+m[i][3]+"\n\n";                              
            }                       
            else if(!m[i][2].equals("=")){ // INT A
                asignacionData("?",m[i][3]); 
            }                                                
            if(validarNombreTemp(m[i][3])){ // B C + T1
                asignacionData("?",m[i][3]); 
            }                                    
        }                
    }
    
        
    static void suma(String op1,String op2,String res){
        code+=";realizar suma\n";
        code+="mov al,"+op1+"\n";
        code+="add al,"+op2+"\n";
        code+="mov "+res+",al\n\n";        
    }
    static void resta(String op1,String op2,String res){
        code+=";realizar resta\n";
        code+="mov al,"+op1+"\n";
        code+="sub al,"+op2+"\n";
        code+="mov "+res+",al\n\n";        
    }  
    static void mul(String op1,String op2,String res){
        code+=";realizar mul\n";
        code+="mov al,"+op1+"\n";
        code+="mov bl,"+op2+"\n";
        code+="mul bl\n";
        code+="mov "+res+",al\n\n";        
    }
    static void div(String op1,String op2,String res){
        code+=";realizar div\n";
        code+="xor ax,ax\n";
        code+="mov al,"+op1+"\n";
        code+="mov bl,al\n";
        code+="mov al,"+op2+"\n";
        code+="div bl\n";
        code+="mov bl,al\n";
        code+="mov "+res+",al\n\n";        
    }
    static void condicion(String op1,String op2,String op,String res){
        code+=";realizar comparacion\n";
        if (op.equals(">")) {
            op="ja";
        }else{
            op="jb";
        }
        code+="mov cl,"+op1+"\n";
        code+="cmp cl,"+op2+"\n";
        code+=op+" e"+res+"\n";
    }

    static void writeVar(String var){
        code+=";escribir una variable\n";
        code+="mov dl,"+var+"\n";
        code+="add dl,30h\n";
        code+="mov ah,02h\n";
        code+="int 21h\n\n";       
    }
    static void writeMsg(String msg){
        code+=";escribir un mensaje\n";
        code+="mov ah,09h\n";
        code+="lea dx,"+msg+"\n";
        code+="int 21h\n\n";        
    }
    static void read(String op1){
        code+=";leer una variable \n";
        code+="mov ah, 01h\n";
        code+="int 21h\n";
        code+="sub al,30h\n";
        code+="mov "+op1+",al\n\n";
    }     
    static void asignacionData(String op1,String res){        
        data+=res+" db "+op1+"\n";                
    }
    static String asignacionDataMsg(String op1){
        String msg=newMsg();
        data+=msg+" db "+op1+",10,13,'$'\n";
        return msg;
    }
    static String newMsg() {
        return "msg" + Integer.toString(++contMsg);
    }
    
    
    static boolean validarNombreTemp(String s){
        if (!s.startsWith("T")) {
            return false;
        }
        for (int i = 1; i < s.length(); i++) {
            if (!"1234567890".contains(String.valueOf(s.charAt(i)))) { 
                return false;
            }
        }
        return true;
    }
    
    
    
    static String[][] tabla_to_mat1(String s) {
        StringTokenizer t = new StringTokenizer(s, "\n");
        String[][] matriz = new String[t.countTokens()][4];

        for (int i = 0; i < matriz.length; i++) {
            StringTokenizer t_aux = new StringTokenizer(t.nextToken(), "\t");
            switch (t_aux.countTokens()) {
                case 4:
                    //t1=a+b;
                    matriz[i][0] = t_aux.nextToken();
                    matriz[i][1] = t_aux.nextToken();
                    matriz[i][2] = t_aux.nextToken();
                    matriz[i][3] = t_aux.nextToken();
                    break;
                case 3:
                    // z = t1;
                    matriz[i][0] = t_aux.nextToken();
                    matriz[i][1] = "";
                    matriz[i][2] = t_aux.nextToken();
                    matriz[i][3] = t_aux.nextToken();
                    break;
                case 2:
                    // write t1; read a;
                    matriz[i][0] = t_aux.nextToken();
                    matriz[i][1] = "O";
                    matriz[i][2] = "O";
                    matriz[i][3] = t_aux.nextToken();
                    break;
                case 1:
                    // write t1; read a;
                    matriz[i][0] = "";
                    matriz[i][1] = "O";
                    matriz[i][2] = "O";
                    matriz[i][3] = t_aux.nextToken();
                    break;
                default:
                    break;
            }
            
        }
        return matriz;
    }
    static void tablaFinal() {
        tablaC = "";
        for (int i = 0; i < arrTemp.length; i++) {
            if (arrTemp[i] != null && !"".equals(arrTemp[i])) {
                tablaC += arrOp1[i] + "\t" + arrOp2[i] + "\t" + arrOp[i] + "\t" + arrTemp[i] + "\n";
            }
        }
    }

    static void optimizacion() {
        for (int i = 0; i < arrTemp.length; i++) {
            if (arrTemp[i] != null) {
                operacion();
                nulas();
                asignacion();
                lineasRepetidas();
                asignacion();
            } else {
                break;
            }
        }
        System.out.println("Código optimizado***********************");
        imprimir();
        String codigoOptim = imprimirInterfaz();
        textoInterfaz += codigoOptim;
    }

    static void imprimir() {
        System.out.println("Op1" + "\t" + "Op2" + "\t" + "Op" + "\t" + "Res");
        for (int i = 0; i < arrTemp.length; i++) {
            if (arrTemp[i] != null && !"".equals(arrTemp[i])) {
                    System.out.println(arrOp1[i] + "\t" + arrOp2[i] + "\t" + arrOp[i] + "\t" + arrTemp[i]);
                }
            }
        System.out.println("****************************************");
        System.out.println("\n" + "\n");
    }

    static String imprimirInterfaz() {
        String[] temp = arrTemp;
        String[] op1 = arrOp1;
        String[] op = arrOp;
        String[] op2 = arrOp2;
        String res = "";
        for (int i = 0; i < temp.length; i++) {
            if (temp[i] != null && !"".equals(temp[i]) && !" ".equals(temp[i])) {
                if ("O".equals(op2[i]) || "O".equals(op[i]) || "O".equals(op1[i])) {
                    if ("O".equals(op1[i])) {
                        op1[i] = "";                        
                    }
                    op2[i] = "";
                    op[i] = "";
                    res += op1[i] + "\t" + op2[i] + "\t" + op[i] + "\t" + temp[i] + "\n";
                } else {
                    res += op1[i] + "\t" + op2[i] + "\t" + op[i] + "\t" + temp[i] + "\n";
                }
            }
        }
        return res;
    }

    /*  Optimización de código para:
     *  Eliminar linea repetidas
     *  T1 = 3 * A
     *  T2 = 3 * A
     *  T3 = T1 + T2
     * 
     *  El resultado será:
     *  T1 = 3 * A
     *  T3 = T1 + T1  
     */
    static void lineasRepetidas() {
        String[] temp = arrTemp;
        String[] op1 = arrOp1;
        String[] op = arrOp;
        String[] op2 = arrOp2;
        for (int i = 0; i < op1.length; i++) {
            if (op1[i] != null) {
                String tempCambio = temp[i];
                for (int j = 0; j < temp.length; j++) {
                    if (j != i) {
                        if ((!"O".equals(op[i]) && !"O".equals(op1[i]) && !"O".equals(op2[i])) && ((op1[i].equals(op1[j]) && op2[i].equals(op2[j]) && op[i].equals(op[j])) || (op1[i].equals(op2[j]) && op2[i].equals(op1[j])) && op[i].equals(op[j]))) {
                            for (int k = 0; k < temp.length; k++) {
                                if (temp[k] != null) {
                                    if (k != i) {
                                        if (op1[k].equals(temp[j])) {
                                            arrOp1[k] = tempCambio;
                                        }
                                        if (op2[k].equals(temp[j])) {
                                            arrOp2[k] = tempCambio;
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                            arrOp1[j] = "";
                            arrOp2[j] = "";
                            arrOp[j] = "";
                            arrTemp[j] = "";
                        }
                    }
                }
            } else {
                break;
            }
        }
    }

    /*  Optimizacion de código para:
     *  Raliza la susticion de asignaciones
     *  T1 = 5
     *  T2 = T1 + 4
     *
     *  El resultado es: 
     *  T2 = 5 + 4
     */
    static void asignacion() {
        String[] op1 = arrOp1;
        for (int i = 0; i < arrOp.length; i++) {
            if (arrOp1[i] != null) {
                if (!"".equals(arrOp1[i]) && !" ".equals(arrOp1[i]) && !"".equals(arrOp[i]) && !" ".equals(arrOp[i])) {
                    boolean cambios = false;
                    String opRes = arrOp[i];
                    String replace = opRes.replace(" ", "");
                    char opREs1 = replace.charAt(0);
                    if (opREs1 == '=') {
                        String valor = arrOp1[i];
                        String tempValor = arrTemp[i];
                        for (int j = 0; j < arrTemp.length; j++) {
                            if (j != i) {
                                if (op1[j] != null && op1[j] != null) {
                                    String opRes1 = arrOp1[j];
                                    String replace1 = opRes1.replace(" ", "");
                                    if (replace1.equals(tempValor)) {
                                        arrOp1[j] = valor;
                                        cambios = true;
                                    }
                                    String opRes2 = arrOp2[j];
                                    String replace2 = opRes2.replace(" ", "");
                                    if (replace2.equals(tempValor)) {
                                        arrOp2[j] = valor;
                                        cambios = true;
                                    }
                                    if ((arrTemp[j].equals(arrTemp[i]) && arrOp[j].equals(arrOp[i])) && !arrOp.equals("O")) {
                                        arrOp[j] = "";
                                        arrOp1[j] = "";
                                        arrOp2[j] = "";
                                        arrTemp[j] = "";
                                    }
                                } else {
                                    break;
                                }
                            }
                        }
                        if (cambios) {
                            arrOp[i] = "";
                            arrOp1[i] = "";
                            arrOp2[i] = "";
                            arrTemp[i] = "";
                        }
                    }
                }
            } else {
                break;
            }
        }

    }

    /*  Optimizacion de código para:
     *  Raliza la eliminacion de nulas
     *  x+0=x   x-0=x   x*0=0
     *  x*1=x   x/1=x
     */
    static void nulas() {
        String[] op1 = arrOp1;
        String[] op = arrOp;
        String[] op2 = arrOp2;

        /*
         *  For que busca 0 o 1 en los Operadores1
         */
        for (int i = 0; i < op1.length; i++) {
            if (op1[i] != null && !"".equals(op1[i]) && !" ".equals(op1[i])) {
                if (buscaLetras(op1[i]) != true) {
                    String number = op1[i].replace(" ", "");
                    Integer op1Num = Integer.valueOf(number);
                    if (op1Num == 0 && !"".equals(op2[i]) && !" ".equals(op2[i])) {
                        String signo = op[i].replace(" ", "");
                        char opSigno = signo.charAt(0);
                        if (opSigno == '+' || opSigno == '-' || opSigno == '*') {
                            switch (opSigno) {
                                case '+':
                                case '-':
                                    String res = op2[i];
                                    arrOp1[i] = res;
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                                case '*':
                                    arrOp1[i] = "0";
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                            }
                        }
                    } else {
                        if (op1Num == 1 && !"".equals(op2[i]) && !" ".equals(op2[i])) {
                            String signo = op[i].replace(" ", "");
                            char opSigno = signo.charAt(0);
                            if (opSigno == '*' || opSigno == '/') {
                                switch (opSigno) {
                                    case '*':
                                    case '/':
                                        String res = op2[i];
                                        arrOp1[i] = res;
                                        arrOp2[i] = "";
                                        arrOp[i] = "=";
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }

        /*
         *  For que busca 0 o 1 en los Operadores2
         */
        for (int i = 0; i < op1.length; i++) {
            if (op2[i] != null && !"".equals(op2[i]) && !" ".equals(op2[i])) {
                if (buscaLetras(op2[i]) != true) {
                    String number = op2[i].replace(" ", "");
                    Integer op2Num = Integer.valueOf(number);
                    if (op2Num == 0 && !"".equals(op1[i]) && !" ".equals(op1[i])) {
                        String signo = op[i].replace(" ", "");
                        char opSigno = signo.charAt(0);
                        if (opSigno == '+' || opSigno == '-' || opSigno == '*') {
                            switch (opSigno) {
                                case '+':
                                case '-':
                                    String res = op1[i];
                                    arrOp1[i] = res;
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                                case '*':
                                    arrOp1[i] = "0";
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                            }
                        }
                    } else {
                        if (op2Num == 1 && !"".equals(op1[i]) && !" ".equals(op1[i])) {
                            String signo = op[i].replace(" ", "");
                            char opSigno = signo.charAt(0);
                            if (opSigno == '*' || opSigno == '/') {
                                switch (opSigno) {
                                    case '*':
                                    case '/':
                                        String res = op1[i];
                                        arrOp1[i] = res;
                                        arrOp2[i] = "";
                                        arrOp[i] = "=";
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /*
     *  Realiza optimización de código para: 
     *  hacer las operaciones
     *  5 * 4 = 20, etc.
     */
    static void operacion() {
        String[] op1 = arrOp1;
        String[] op = arrOp;
        String[] op2 = arrOp2;
        for (int i = 0; i < op1.length; i++) {
            if (op1[i] != null) {
                if (!"".equals(op1[i]) && !" ".equals(op1[i])) {
                    if (buscaLetras(op1[i]) != true && buscaLetras(op2[i]) != true) {
                        String number = op1[i];
                        String replace = number.replace(" ", "");
                        Integer op1Num = Integer.valueOf(replace);
                        int resultado = 0;
                        String opString = op[i].replace(" ", "");
                        char opSigno = opString.charAt(0);
                        if (buscaLetras(op2[i]) != true && (opSigno == '+' || opSigno == '-' || opSigno == '*' || opSigno == '/')) {
                            number = op2[i].replace(" ", "");
                            Integer op2Num = Integer.valueOf(number);
                            String nuevoValor;

                            switch (opSigno) {
                                case '+':
                                    resultado = op1Num + op2Num;
                                    nuevoValor = Integer.toString(resultado);
                                    arrOp1[i] = nuevoValor;
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                                case '-':
                                    resultado = op1Num - op2Num;
                                    nuevoValor = Integer.toString(resultado);
                                    arrOp1[i] = nuevoValor;
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                                case '*':
                                    resultado = op1Num * op2Num;
                                    nuevoValor = Integer.toString(resultado);
                                    arrOp1[i] = nuevoValor;
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                                case '/':
                                    resultado = op1Num / op2Num;
                                    nuevoValor = Integer.toString(resultado);
                                    arrOp1[i] = nuevoValor;
                                    arrOp2[i] = "";
                                    arrOp[i] = "=";
                                    break;
                            }
                        }
                    }
                }
            } else {
                break;
            }
        }
    }


    /*
     *   Busca si hay un letra en alguna cadena 
     *   "T1"    -> Tiene letra
     *   "C"     -> Tiene letra           
     *   "8"     -> No tiene letra
     */
    static boolean buscaLetras(String s) {
        boolean res = false;
        char letra;
        if (!"".equals(s) && !" ".equals(s)) {
            for (int i = 0; i < s.length(); i++) {
                letra = s.charAt(i);
                if ((letra >= 63 && letra <= 90) || (letra >= 97 && letra <= 122)) {
                    res = true;
                    break;
                }
            }
        }
        return res;
    }

    static void bloques(String s) {//separar por bloques         
        String[][] m = tabla_to_mat(s);

        m = optimizacionEtiquetas(m);
        //el primer cuadruple es bloque
        m[0][4] = newBlock();
        for (int i = 0; i < m.length; i++) {//ciclo para asignar bloques
            if (validacionNum(m[i][3])) { //valida si es un numero en la 4ta posicion (que quiere decir que es un salto condicional)
                m = asignarBloques(m, i, m[i][3]);
            }
        }
        System.out.println(" *************** Asignar bloques ***************");
        imprimirMatriz(m);
        contB = 0;
        m[0][4] = "";
        String aux = "";
        System.out.println("\n\n\n");
        for (int i = 0; i < m.length; i++) {//ciclo para optimizar bloques                        
            if (m[i][4].contains("B")) { //si es un fin de bloque
                optimizacionGeneral(aux);
                aux = m[i][0] + "\t" + m[i][1] + "\t" + m[i][2] + "\t" + m[i][3] + "\n";
            } else {
                aux += m[i][0] + "\t" + m[i][1] + "\t" + m[i][2] + "\t" + m[i][3] + "\n";
            }
        }
        optimizacionGeneral(aux);
    }

    static String[][] optimizacionEtiquetas(String[][] m) {
        int cont;
        String s;

        for (int i = 0; i < m.length; i++) {
            s = "";
            if (m[i][3].contains(":")) { //recorre el arreglo hasta encontrar un (10:)
                s = m[i][3];
                cont = i;
                while (++cont < m.length) { //validacion de que no recorra más del largo del arreglo
                    if (m[cont][3].contains(":")) {
                        s += m[cont][3]; //guarda los valores 10: 20: 30: mientras sean consecutivos  
                        m[cont][3] = "";
                    } else {// cuando dejan de ser consecutivos                                                                                                                                                                   
                        break;
                    }
                }
            }

            if (!s.equals("")) {
                StringTokenizer t = new StringTokenizer(s, ":"); //ejemplo de entradas (10:)(10:20:30:)                        
                if (t.countTokens() != 1) { //caso en el que solo sea un valor 10: se sale del while
                    String[] array = new String[t.countTokens()];
                    for (int j = 0; j < array.length; j++) {
                        array[j] = t.nextToken();
                    }
                    //recorrer la matriz para sustituir ahora que tenemos los valores iguales en un arreglo(10:20:30:)
                    for (int j = 0; j < m.length; j++) {
                        if (validacionNum(m[j][3])) { // si es 30 de goto 30
                            for (int k = 0; k < array.length; k++) { //recorrer el arreglo para cerificar si el valor es igual a los valores identicos guardados anteriormente
                                if (array[k].equals(m[j][3])) {
                                    m[j][3] = array[0];//sustituir por el primer valor
                                }
                            }
                        }
                    }
                }
            }

        }

        s = "";
        for (int i = 0; i < m.length; i++) {
            if (!"".equals(m[i][3])) {
                s += m[i][0] + "\t" + m[i][1] + "\t" + m[i][2] + "\t" + m[i][3] + "\n";
            }
        }
        m = tabla_to_mat(s);
        return m;
    }

    public static void optimizacionGeneral(String s) {
        String[][] m = tabla_to_mat(s);
        limpiar();
        for (int i = 0; i < m.length; i++) {
            arrTemp[i] = m[i][3];
            arrOp1[i] = m[i][0];
            arrOp[i] = m[i][2];
            arrOp2[i] = m[i][1];
        }
        imprimirMatriz(m);
        optimizacion();
    }

    static void limpiar() {
        for (int i = 0; i < arrTemp.length; i++) {
            arrTemp[i] = null;
            arrOp1[i] = null;
            arrOp2[i] = null;
            arrOp[i] = null;
        }
    }

    private static String[][] asignarBloques(String[][] m, int pos, String num) {
        String aux;
        for (int i = 0; i < m.length; i++) {
            if (m[i][3].contains(":")) {
                aux = "";
                for (int j = 0; j < m[i][3].length() - 1; j++) {
                    aux += m[i][3].charAt(j);
                }
                if (aux.equals(num)) {
                    m[i][4] += newBlock(); //cualquier instruccion que sea destino de un salto condicional es lider
                }
            }
        }
        m[pos + 1][4] += newBlock();//cualquier instruccion que siga despues de un salto condicional es lider        
        return m;
    }

    static boolean validacionNum(String s) {
        for (int i = 0; i < s.length(); i++) {
            if (!"1234567890".contains(Character.toString(s.charAt(i)))) {
                return false;
            }
        }
        return true;
    }

    static int contB = 0;

    static String newBlock() {
        return "-----B" + Integer.toString(++contB);
    }

    static String[][] tabla_to_mat(String s) {
        StringTokenizer t = new StringTokenizer(s, "\n");
        String[][] matriz = new String[t.countTokens()][5];

        for (int i = 0; i < matriz.length; i++) {

            StringTokenizer t_aux = new StringTokenizer(t.nextToken(), "\t");
            switch (t_aux.countTokens()) {
                case 4:
                    //t1=a+b;
                    matriz[i][0] = t_aux.nextToken();
                    matriz[i][1] = t_aux.nextToken();
                    matriz[i][2] = t_aux.nextToken();
                    matriz[i][3] = t_aux.nextToken();
                    break;
                case 3:
                    // z = t1;
                    matriz[i][0] = t_aux.nextToken();
                    matriz[i][1] = "";
                    matriz[i][2] = t_aux.nextToken();
                    matriz[i][3] = t_aux.nextToken();
                    break;
                case 2:
                    // write t1; read a;
                    matriz[i][0] = t_aux.nextToken();
                    matriz[i][1] = "O";
                    matriz[i][2] = "O";
                    matriz[i][3] = t_aux.nextToken();
                    break;
                case 1:
                    // write t1; read a;
                    matriz[i][0] = "";
                    matriz[i][1] = "O";
                    matriz[i][2] = "O";
                    matriz[i][3] = t_aux.nextToken();
                    break;
                default:
                    break;
            }
            matriz[i][4] = "";
        }

        return matriz;

    }

    static void imprimirMatriz(String[][] m) {
        for (int i = 0; i < m.length; i++) {
            for (int j = 0; j < m[i].length; j++) {
                System.out.print(m[i][j] + "\t");	// Imprime elemento
            }
            System.out.println();	// Imprime salto de línea
        }
    }

    static String juntarLineas(String str) {
        str = agregarEspacios(str, separadoresAux);

        StringTokenizer t = new StringTokenizer(str, "\n");
        str = "";
        while (t.hasMoreTokens()) {
            str += t.nextToken() + " ";
        }

        StringTokenizer t1 = new StringTokenizer(str, "\t");
        str = "";
        while (t1.hasMoreTokens()) {
            str += t1.nextToken() + " ";
        }

        return str;
    }

    static void sent(String sentencias) {
        sentencias = agregarEspacios(sentencias, separadoresAux);
        String[] array = strToArray(sentencias);
        if (array.length <= 1) {
            return;
        }
        if (!array[0].equals("IF") && !array[0].equals("WHILE")) {
            if (array[0].equals("READ")) { //--------------------------- READ
                System.out.println("READ " + array[2] + "\n");
                codigoI += "READ " + array[2] + "\n";
                tablaC += array[2] + "\t\t\t" + "READ" + "\n";
                tablaBloques += array[2] + "\t\t\t" + "READ" + "\n";
            } else if (array[0].equals("WRITE")) { //--------------------------- WRITE                                                                                
                String aux = "";
                for (int i = 1; i < array.length; i++) {//WRITE ( ... );
                    if (array[i].equals(";")) {
                        break;
                    }
                    aux += array[i] + " ";
                }

                aux = quitarOpArit(postfijoOrlas(aux));
                System.out.println("WRITE " + aux + "\n");
                codigoI += "WRITE " + aux + "\n";
                tablaC += aux + "\t\t\t" + "WRITE" + "\n";
                tablaBloques += aux + "\t\t\t" + "WRITE" + "\n";

            } else if (array[0].contains("INT") || array[0].equals("INT")) { // --------------(INT Z;)                                              
                System.out.println("" + array[1] + "\n");
                codigoI += "" + array[1] + "\n";
                tablaC += "\t\t\t" + array[1] + "\n";
                tablaBloques += "O\tO\tO\t" + array[1] + "\n";
            } else { //--------------------------- asignacion
                String aux = "", op, op1, res;
                for (int i = 2; i < array.length; i++) {//Z = ... ;
                    if (array[i].equals(";")) {
                        break;
                    }
                    aux += array[i] + " ";
                }

                aux = quitarOpArit(postfijoOrlas(aux));
                res = array[0]; // res = "Z";
                op = array[1]; // op = "=";
                op1 = aux; //op1 = "Temp10";
                System.out.println(res + "=" + op1 + "\n");
                codigoI += res + "=" + op1 + "\n";
                tablaBloques += op1 + "\t\t=\t" + res + "\n";
            }
            for (int i = 0; i < array.length; i++) { //--------------------------- quitar una sentencia
                if (array[i].equals(";")) {
                    array[i] = null;
                    break;
                }
                array[i] = null;
            }
            array = quitarNulos(array);
            sent(arrayToStr(array)); //--------------------------- recursividad

        } else { //--------------------------- WHILE o IF o IF ELSE                   
            String bcode = "";
            for (int j = 1; j < array.length; j++) { //( a > b | 5 + b * c > j & c < d ) 
                if (array[j].equals("{")) {
                    break;
                }
                bcode += array[j] + " ";
                array[j] = null;
            }
            System.out.println("Condicion:\n" + bcode + "\n");
            bcode = postfijoOrlas(bcode);
            System.out.println("Condicion postfijo:\n" + bcode + "\n");
            bcode = quitarOpArit(bcode);
            System.out.println("Condicion postfijo con temporales:\n" + bcode + "\n"); //temp1 temp2 <

            array = quitarNulos(array);//WHILE { WRITE ( A ) ; WRITE ( B ) ; } READ ( A ) ;                       

            int llaveA = 0, llaveC = 0, i;
            for (i = 0; i < array.length; i++) {
                if (llaveA == llaveC && llaveA != 0) {
                    break;
                }
                if (array[i].equals("{")) {
                    llaveA++;
                }
                if (array[i].equals("}")) {
                    llaveC++;
                }
            }

            boolean mientras = false, ifelse = false;

            if (array[0].equals("WHILE")) { //--------------------------- WHILE
                mientras = true;
            }

            String s1code = "";
            String s2code = "";
            array[0] = null; //WHILE    //IF
            array[1] = null; //{
            array[(i - 1)] = null;//}
            for (int j = 2; j < (i - 1); j++) {
                s1code += array[j];
                array[j] = null;
            } //--------------------------- s1code = WRITE(A);WRITE(B); ...                                                
            array = quitarNulos(array);

            if (array.length != 0) {
                if (array[0].equals("ELSE")) {
                    ifelse = true;
                    llaveA = 0;
                    llaveC = 0;
                    for (i = 0; i < array.length; i++) {
                        if (llaveA == llaveC && llaveA != 0) {
                            break;
                        }
                        if (array[i].equals("{")) {
                            llaveA++;
                        }
                        if (array[i].equals("}")) {
                            llaveC++;
                        }
                    }
                    array[0] = null; //ELSE
                    array[1] = null; //{
                    array[(i - 1)] = null;//}
                    for (int j = 2; j < (i - 1); j++) {
                        s2code += array[j];
                        array[j] = null;
                    } //--------------------------- s2code = WRITE(A);WRITE(B); ...                
                    array = quitarNulos(array);
                }
            }

            //etiquetas
            int es, ef, ev, ei = 0;
            es = newlabel();
            if (mientras) {
                ei = newlabel();
                ev = newlabel();
                ef = es;
                // label(ei) ||
                System.out.println(ei + ": ");
                codigoI += ei + ":\n";
                tablaC += "\t\t\t" + ei + ":\n";
                tablaBloques += "\t\t\t" + ei + ":\n";
            } else if (ifelse) {
                ev = newlabel();
                ef = newlabel();
            } else {
                ev = newlabel();
                ef = es;
            }

            //B.code ||
            bcode(bcode, ev, ef);

            //label(ev) ||    
            System.out.println(ev + ": \n");
            tablaC += "\t\t\t" + ev + ":\n";
            tablaBloques += "\t\t\t" + ev + ":\n";
            codigoI += ev + ":\n";

            //s1.code ||
            sent(s1code); //--------------------------- recursividad

            if (ifelse || mientras) {

                if (mientras) {// //--------------------------- while
                    //gen('goto' ei)
                    System.out.println("\tgoto " + ei);
                    codigoI += "\tgoto " + ei + "\n";
                    tablaC += "\t\t\t" + ei + "\n";
                    tablaBloques += "\t\t\t" + ei + "\n";

                } else {   //--------------------------- IF    IF ELSE
                    //gen('goto' es)
                    System.out.println("\tgoto " + es);
                    codigoI += "\tgoto " + es + "\n";
                    tablaC += "\t\t\t" + es + "\n";
                    tablaBloques += "\t\t\t" + es + "\n";
                    //label(ef) ||
                    System.out.println(ef + ": ");
                    codigoI += ef + ": " + "\n";
                    tablaC += "\t\t\t" + ef + ":\n";
                    tablaBloques += "\t\t\t" + ef + ":\n";
                    //s2.code |||
                    sent(s2code); //--------------------------- recursividad                                    
                }

            }

            //label(S.next)
            System.out.println(es + ": ");
            codigoI += es + ": " + "\n";
            tablaC += "\t\t\t" + es + ":\n";
            tablaBloques += "\t\t\t" + es + ":\n";

            sent(arrayToStr(array)); //--------------------------- recursividad
        }

    }

    static void bcode(String bcode, int bt, int bf) {
        String[] array = strToArray(bcode);
        if (array.length == 3) {
            procesarOpRel(bcode, bt, bf);
            return;
        }

        String cadena = "";
        int cont = 0, i;

        //generar temporales para los operadores relacionales 
        while (bcode.contains(">") || bcode.contains("<")) {
            array = strToArray(bcode);

            for (i = 0; i < array.length; i++) {
                if ("<>".contains(array[i])) {
                    break;
                }
            }
            cadena += "opeRe" + Integer.toString(++cont) + "=" + array[i - 2] + "," + array[i - 1] + "," + array[i] + ";\n";
            array[i] = "opeRe" + Integer.toString(cont);
            array[i - 1] = null;
            array[i - 2] = null;
            array = quitarNulos(array);
            bcode = arrayToStr(array);
        }

        //generar temporales para los operadores logicos 
        cont = 0;
        while (bcode.contains("|") || bcode.contains("&")) {
            array = strToArray(bcode);

            for (i = 0; i < array.length; i++) {
                if ("|&".contains(array[i])) {
                    break;
                }
            }
            cadena += "opeLog" + Integer.toString(++cont) + "=" + array[i - 2] + "," + array[i - 1] + "," + array[i] + ";\n";
            array[i] = "opeLog" + Integer.toString(cont);
            array[i - 1] = null;
            array[i - 2] = null;
            array = quitarNulos(array);
            bcode = arrayToStr(array);
        }

        lineas = separarLineas(cadena);
        String[] columnas;
        lineas[lineas.length - 1] = ponerEtiq(lineas[lineas.length - 1], bt, bf);

        for (int j = 0; j < lineas.length; j++) {
            System.out.println("----- " + j + ": " + lineas[j]);
        }

    }

    static String ponerEtiq(String str, int bt, int bf) {// opeLog2 = opeRe1,opeLog1, | ; 

        int b1t = 0, b1f = 0, b2t = 0, b2f = 0;
        str = agregarEspacios(str, separadoresAux);
        String[] array = strToArray(str);
        boolean o = false;
        if (array.length != 8) {
            return str;
        }

        String aux;
        aux = array[array.length - 2];

        if (aux.equals("|")) {  // opeLog2 = opeRe1,opeLog1, | ; 
            o = true;
            b1t = bt;
            b1f = newlabel();
            b2t = bt;
            b2f = bf;
            aux = Integer.toString(b1t) + "," + Integer.toString(b1f) + "," + Integer.toString(b2t) + "," + Integer.toString(b2f) + ";";
            str += aux;
        } else if (aux.equals("&")) {
            b1t = newlabel();
            b1f = bf;
            b2t = bt;
            b2f = bf;
            aux = Integer.toString(b1t) + "," + Integer.toString(b1f) + "," + Integer.toString(b2t) + "," + Integer.toString(b2f) + ";";
            str += aux;
        }

        //izquierda
        if (array[2].contains("opeRe")) {

            for (int i = 0; i < lineas.length; i++) {
                String aux1 = agregarEspacios(lineas[i], separadoresAux);
                String[] auxLineas = strToArray(aux1);
                if (array[2].equals(auxLineas[0])) {

                    lineas[i] += Integer.toString(b1t) + "," + Integer.toString(b1f) + ";";

                    String[] columnas = strToArray(agregarEspacios(lineas[i], separadoresAux));
                    String aux2 = columnas[2] + " " + columnas[4] + " " + columnas[6];

                    procesarOpRel(aux2, Integer.parseInt(columnas[8]), Integer.parseInt(columnas[10]));
                    if (o) {
                        System.out.println(b1f + ": ");
                        codigoI += b1f + ":\n";
                        tablaC += "\t\t\t" + b1f + ":\n";
                        tablaBloques += "\t\t\t" + b1f + ":\n";
                    } else {
                        System.out.println(b1t + ": ");
                        codigoI += b1t + ":\n";
                        tablaC += "\t\t\t" + b1t + ":\n";
                        tablaBloques += "\t\t\t" + b1t + ":\n";
                    }

                    break;
                }
            }

        } else if (array[2].contains("opeLog")) {

            for (int i = 0; i < lineas.length; i++) {
                String aux1 = agregarEspacios(lineas[i], separadoresAux);
                String[] auxLineas = strToArray(aux1);
                if (array[2].equals(auxLineas[0])) {

                    lineas[i] += ponerEtiq(lineas[i], b1t, b1f);
                    break;
                }
            }

        }

        //derecha
        if (array[4].contains("opeRe")) {

            for (int i = 0; i < lineas.length; i++) {
                String aux1 = agregarEspacios(lineas[i], separadoresAux);
                String[] auxLineas = strToArray(aux1);
                if (array[4].equals(auxLineas[0])) {
                    lineas[i] += Integer.toString(b2t) + "," + Integer.toString(b2f) + ";";

                    String[] columnas = strToArray(agregarEspacios(lineas[i], separadoresAux));
                    String aux2 = columnas[2] + " " + columnas[4] + " " + columnas[6];
                    procesarOpRel(aux2, Integer.parseInt(columnas[8]), Integer.parseInt(columnas[10]));

                    break;
                }
            }

        } else if (array[4].contains("opeLog")) {

            for (int i = 0; i < lineas.length; i++) {
                String aux1 = agregarEspacios(lineas[i], separadoresAux);
                String[] auxLineas = strToArray(aux1);
                if (array[4].equals(auxLineas[0])) {

                    lineas[i] += ponerEtiq(lineas[i], b2t, b2f);
                    break;
                }
            }

        }

        return str; // opeLog2 = opeRe1,opeLog1, | ; 20,30,20,10;
    }

    static void sentenciasAux(String cf) {
        cf = agregarEspacios(cf, separadoresAux);
        String[] array = strToArray(cf);
        if (array.length == 0) {
            return;
        }
        int llaveA = 0, llaveC = 0;
        String str = "";
        for (int i = 0; i < array.length; i++) {
            if (llaveA == llaveC && llaveA != 0) {
                break;
            }

            if (array[i].equals("{")) {
                llaveA++;
            }
            if (array[i].equals("}")) {
                llaveC++;
            }
            str += array[i] + " ";
            array[i] = null;
        }
        System.out.println("---" + str);
        sentencias(str);
        array = quitarNulos(array);
        codigoI += "\n";
        sentenciasAux(arrayToStr(array));
    }

    static int newlabel() {

        return contEtiq += 10;
    }

    static void procesarOpRel(String cf, int ev, int ef) {
        String[] array = strToArray(cf);
        String op, op1, op2;
        op1 = array[0];
        op2 = array[1];
        op = array[2];
        System.out.println("IF " + op1 + " " + op + " " + op2 + " goto " + ev + "\n\tgoto " + ef);
        codigoI += "IF " + op1 + " " + op + " " + op2 + " goto " + ev + "\n\tgoto " + ef + "\n";
        tablaC += op1 + "\t" + op2 + "\t" + op + "\t" + ev + "\n";
        tablaBloques += op1 + "\t" + op2 + "\t" + op + "\t" + ev + "\n";
        tablaC += "\t\t\t" + ef + "\n";
        tablaBloques += "\t\t\t" + ef + "\n";
    }

    static void ifAndWhile(String cf) { //WHILE(a>b|5+b*c>j&c<d){WRITE(A);}
        int es;
        boolean mientras = false;
        if (cf.startsWith("IF")) {
            System.out.println("If: \n" + cf + "\n");
        } else {
            System.out.println("While: \n" + cf + "\n");
            mientras = true;
        }

        cf = agregarEspacios(cf, separadoresAux);
        String[] array = strToArray(cf);
        String aux = "";
        for (int i = 2; i < array.length; i++) {//guardar solo la bcode (sin parentesis)
            if (array[i].equals(")") && array[i + 1].equals("{")) {
                break;
            }
            aux += array[i] + " ";
            array[i] = null;
        }
        System.out.println("Condicion (sin parentesis):\n" + aux + "\n");
        System.out.println("Postfijo(nuevo): \n" + postfijoOrlas(aux) + "\n");
        cf = quitarOpArit(postfijoOrlas(aux));
        System.out.println("Condicion sin opeArit: \n" + cf + "\n");

        //etiquetas
        if (mientras) {
            ei = newlabel();
            //label(ei)
            System.out.println(ei + ": ");
            codigoI += ei + ":\n";
            tablaC += "\t\t\t" + ei + ":\n";
            tablaBloques += "\t\t\t" + ei + ":\n";
        }
        es = newlabel();
        ef = es;

        //B.code
        if (cf.contains("|") || cf.contains("&")) {//con operadores logicos           
            char raiz = cf.charAt(cf.length() - 2);
            idr(cf, String.valueOf(raiz), ev = newlabel(), ef);
        } else {//un operador relacional simple (T1 T2 <)                                                      
            procesarOpRel(cf, ev = newlabel(), ef);
        }

        //label(ev)||S1.code
        System.out.println(ev + ": \n");
        tablaC += "\t\t\t" + ev + ":\n";
        tablaBloques += "\t\t\t" + ev + ":\n";
        codigoI += ev + ": \n";
        //String strAux = sentencias(arrayToStr(array));//IF ()[WRITE(A);}  // WHILE ()[WRITE(A);} 
        array = quitarNulos(array);
        array[0] = null;//IF || WHILE
        array[1] = null;//(
        array[2] = null;//)
        array[3] = null;//{

        array = quitarNulos(array);
        for (int i = 0; i < array.length; i++) { //}
            if (array[i].equals("}")) {
                array[i] = null;
                break;
            }
        }

        array = quitarNulos(array);// WRITE(A); WRITE(B); IF(A<B){<S>} WHILE(){<S>}

        sentenciasAux(arrayToStr(array));//IF (){WRITE(A);}  // WHILE (){WRITE(A);} 

        if (mientras) {
            //gen('goto' ei)
            System.out.println("\tgoto " + ei);
            codigoI += "\tgoto " + ei + "\n";
        }

        //label(S.next)
        System.out.println(es + ": ");
        codigoI += es + ": " + "\n";
        tablaC += "\t\t\t" + es + ":\n";
        tablaBloques += "\t\t\t" + es + ":\n";
    }
    static int b1v, b1f, b2v, b2f;

    static void idr(String str, String raiz, int bt, int bf) {//T3 d < T6 g < |   

        String[] array = strToArray(str);
        if (array.length == 0) { //si ya se termino toda la bcode
            return;
        }

        String aux;
        aux = array[array.length - 1];
//        System.out.println(str );
//        System.out.println(raiz);
        if (aux.equals("|") || aux.equals("&")) {//es un op logico

            if (aux.equals("|")) {
                b1v = bt;
                b1f = newlabel();
                b2v = bt;
                b2f = bf;
            } else {
                b1v = newlabel();
                b1f = bf;
                b2v = bt;
                b2f = bf;
            }

            array[array.length - 1] = null;
            array = quitarNulos(array);
            idr(arrayToStr(array), aux, b2v, b2f);
            //idr(arrayToStr(array),s1code,b1v,b1f);            
        } else if (aux.equals("<") || aux.equals(">")) {//es un op relacional

            array[array.length - 1] = null;
            array = quitarNulos(array);
            //idr(arrayToStr(array),s1code,1,1);            

            idr(arrayToStr(array), aux, b2v, b2f);
            //idr(arrayToStr(array),s1code,b1v,b1f);            
        } else {//es un terminal            
            //un operador relacional simple (T1 T2 <)                        
            String op, op1, op2;
            op = raiz;
            op2 = array[array.length - 1];
            op1 = array[array.length - 2];
            String cf = op1 + " " + op2 + " " + op;
            procesarOpRel(cf, bt, bf);

            array[array.length - 1] = null;
            array[array.length - 2] = null;
            array = quitarNulos(array);
            idr(arrayToStr(array), aux, 1, 1);
        }
    }

    static void sentencias(String cf) {//IF ()[WRITE(A);}  // WHILE ()[WRITE(A);} 

        cf = agregarEspacios(cf, separadoresAux);
        String[] array = strToArray(cf);

        if (array.length == 0) { //si ya no hay nada mas salir del metodo
            return;
        }

        while (true) {//quitar sentencia por sentencia
            if (array[0].equals("WRITE")) { // WRITE(A); WRITE(B); ...
                System.out.println("WRITE " + array[2] + "\n");
                codigoI += "WRITE " + array[2] + "\n";
                tablaC += array[2] + "\t\t\t" + "WRITE" + "\n";
                tablaBloques += array[2] + "\t\t\t" + "WRITE" + "\n";
                for (int i = 0; i < 5; i++) { // WRITE(A);
                    array[i] = null;
                }
                array = quitarNulos(array);
                if (array.length == 0) { //si ya no hay nada mas salir del metodo
                    return;
                }
            } else {
                break;
            }
        }
        //Tiene if´s

        //IF(){} IF(){}      //IF(){   IF(){}  }     
        int llaveA = 0, llaveC = 0;
        for (int i = 0; i < array.length; i++) {
            if (llaveA == llaveC && llaveA != 0) {
                break;
            }
            if (array[i].equals("{")) {
                llaveA++;
            }
            if (array[i].equals("}")) {
                llaveC++;
            }
        }

        String aux = "";
        if (llaveA == 1) { //IF(){}       
            //ifAndWhile(arrayToStr(array));

            for (int i = 0; i < array.length; i++) { //     WHILE(){}          
                if (array[i].equals("}")) {
                    aux += array[i] + " ";
                    array[i] = null;
                    break;
                }
                aux += array[i] + " ";
                array[i] = null;
            }
            ifAndWhile(aux);
            array = quitarNulos(array);
            sentenciasAux(arrayToStr(array));
        } else {
            //IF(){   IF(){}    }
            llaveA = 1;
            llaveC = 0;
            aux = "";

            for (int i = 0; i < array.length; i++) {// quitar: IF(){ WRITE(A);
                if (array[i].equals("IF") || array[i].equals("WHILE") && i != 0) {
                    break;
                }

                aux += array[i] + " ";
                array[i] = null;
            }

            array = quitarNulos(array);

            for (int i = 0; i < array.length; i++) { //quitar:  } (el que le pertenece)

                if (array[i].equals("{")) {
                    llaveA++;
                }
                if (array[i].equals("}")) {
                    llaveC++;
                }

                if (llaveA == llaveC && llaveA != 0) {
                    aux += array[i];
                    array[i] = null;
                    break;
                }

            }

            array = quitarNulos(array);
            ifAndWhile(aux + " " + arrayToStr(array));
            //sentencias(arrayToStr(array));

        }

    }

    static String quitarOpArit(String postfijo) {
        //si no hay operadores aritmeticos lo regresamos como estaba               
        if (!(postfijo.contains("+") || postfijo.contains("-") || postfijo.contains("*") || postfijo.contains("/"))) {
            return postfijo;
        }

        //postfijo a array        
        String[] array = strToArray(postfijo);
        String op, op1, op2, strTemporales = "";

        int i;

        while (postfijo.contains("+") || postfijo.contains("-") || postfijo.contains("*") || postfijo.contains("/")) {

            for (i = 0; i < array.length; i++) {
                if (opArit.contains(array[i])) {
                    break;
                }
            }
            op = array[i];//posicion i=operando
            op2 = array[i - 1];//posicion i-1=op2
            op1 = array[i - 2];//posicion i-2=op1                                    

            String temp = "T" + (++numTemp);
            strTemporales += temp + " = " + op1 + " " + op + " " + op2 + "\n";
            tablaC += op1 + "\t" + op2 + "\t" + op + "\t" + temp + "\n";
            tablaBloques += op1 + "\t" + op2 + "\t" + op + "\t" + temp + "\n";

            //quitamos los valores que ya pusimos en temporales de operaciones aritmeticas
            array[i] = null;
            array[i - 1] = null;
            array[i - 2] = null;
            //array[i] = "T" + numTemp;//remplazamos el temporal en el postfijo nuevo
            array[i] = temp;//remplazamos el temporal en el postfijo nuevo
            array = quitarNulos(array);

            postfijo = arrayToStr(array);
        }
        System.out.println(strTemporales);
        return postfijo;
    }

    static String postfijoOrlas(String str) {

        str = agregarEspacios(str, "(){}<>+-*/=;|&"); //agregar espacios dependiendo de separadores auxiliares
        String[] array = strToArray(str);//se convierte en un array de "palabras"

        if (array.length == 1) { //A            
            return str;
        }

        int prioridadStr, prioridadPila2;
        String pila1 = "";
        Stack<String> pila2 = new Stack<String>();

        for (int i = 0; i < array.length; i++) {  //se debe recorrer todo el array     
            if ("*/+-><&|()".contains(array[i])) {//todo el rollo de comparar los operandos                

                if (array[i].equals("(")) { //solamnete meter el parentesis e ignorar las demás reglas
                    pila2.push(array[i]);

                } else if (array[i].equals(")")) { //sacar de p2 y meter en p1 hasta encontrarse un (
                    String aux;
                    while (true) {
                        aux = pila2.pop();
                        pila1 += aux + " ";
                        if (aux.equals("(")) {
                            break;
                        }
                    }

                } else {
                    if (pila2.empty()) {
                        pila2.push(array[i]);
                    } else {

                        prioridadStr = prioridadDe(array[i]);//regresa la prioridad(1 para |, 2 para &, 3 para <>, 4 para +-, 5 para */)
                        prioridadPila2 = prioridadDe(pila2.lastElement());
                        boolean bandera = false;
                        //sacar los elemntos de la pila2 a la pila1 mientras la prioridad del elemnto de la p1 sea menor al ultimo de la p2
                        while (prioridadStr <= prioridadPila2 && !pila2.empty()) {
                            prioridadPila2 = prioridadDe(pila2.lastElement());//obtener la nueva prioridad del ultimo de p2                                        
                            if (prioridadStr <= prioridadPila2) {
//                        if(prioridadStr == prioridadPila2){
//                            prioridadPila2=0;
//                            break;
//                        }              
                                bandera = true;
                                pila1 += pila2.pop() + " ";
                            }
                        }
                        if (bandera) { //se va a poner en pila 2 porque ya se vio que era menor en la prioridad y ya se sacaron a los de mayor prioridad
                            pila2.push(array[i]);
                        } else if (prioridadStr >= prioridadPila2) {//se guarda en pila 2 porque ya que no lleva una prioridad correcta
                            pila2.push(array[i]);
                        }
                    }
                }

            } else {//es un identificador o numero (A,B,X1, 5, 10)
                pila1 += array[i] + " ";
            }
        }

        pila1 += strPila(pila2); //juntar p1 y p2
        pila1 = quitarParentesis(pila1);
        return pila1;
    }

    static String quitarParentesis(String str) {
        String[] array = strToArray(str);
        str = "";
        for (int i = 0; i < array.length; i++) {
            if (!"()".contains(array[i])) {
                str += array[i] + " ";
            }
        }
        return str;
    }

    static int prioridadDe(String str) {
        int num = 0;
        if (str.equals("*") | str.equals("/")) {
            num = 5;
        } else if (str.equals("+") | str.equals("-")) {
            num = 4;
        } else if (str.equals("<") | str.equals(">")) {
            num = 3;
        } else if (str.equals("&")) {
            num = 2;
        } else if (str.equals("|")) {
            num = 1;
        }
        return num;
    }

    static String strPila(Stack<String> pila) {
        String str = "";
        while (!pila.empty()) {
            str += pila.pop() + " ";
        }
        String[] array = strToArray(str);
        for (int i = array.length - 1; i >= 0; i--) {
            pila.push(array[i]);
        }

        return str;
    }

    static String arrayToStr(String[] array) {
        String str = "";
        for (int i = 0; i < array.length; i++) {
            str += array[i] + " ";
        }
        return str;
    }

    static String[] quitarNulos(String[] array) {
        String str = "";
        for (int i = 0; i < array.length; i++) {
            if (array[i] != null) {
                str += array[i] + " ";
            }
        }
        return strToArray(str);
    }

    static String[] strToArray(String str) {
        //contar el tamaño del array, se utiliza en espacio como delimitador
        StringTokenizer t = new StringTokenizer(str, " ");
        int i = 0;
        while (t.hasMoreTokens()) {
            t.nextToken();
            i++;
        }
        //declarar el arreglo y llenarlo
        String[] aux = new String[i];
        int cont = 0;
        StringTokenizer tokens = new StringTokenizer(str, " ");
        while (tokens.hasMoreTokens()) {
            aux[cont++] = tokens.nextToken();
        }
        return aux;
    }

    static String[] separarLineas(String str) {
        //contar el tamaño del array, se utiliza en espacio como delimitador
        StringTokenizer t = new StringTokenizer(str, "\n");
        int i = 0;
        while (t.hasMoreTokens()) {
            t.nextToken();
            i++;
        }
        //declarar el arreglo y llenarlo
        String[] aux = new String[i];
        int cont = 0;
        StringTokenizer tokens = new StringTokenizer(str, "\n");
        while (tokens.hasMoreTokens()) {
            aux[cont++] = tokens.nextToken();
        }
        return aux;
    }

    static String agregarEspacios(String str, String separador) {
        char[] arr = str.toCharArray();
        str = "";
        for (int i = 0; i < arr.length; i++) {
            if (separador.contains(Character.toString(arr[i]))) {
                str += " " + arr[i] + " ";
            } else {
                str += arr[i];
            }
        }
        return str;
    }

    /**
     * @param args the command line arguments
     */
    //main
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(VentanaU3_01.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(VentanaU3_01.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(VentanaU3_01.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VentanaU3_01.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VentanaU3_01().setVisible(true);
            }
        });
    }

    public String guardarArchivo(String texto) {
        FileWriter archivo = null;
        PrintWriter pw;
        try {
            archivo = new FileWriter("texto.txt", false);
            pw = new PrintWriter(archivo);
            pw.println(texto);
        } catch (Exception e) {
            System.out.println("Error al cerrar el archivo");
        } finally {
            try {
                if (null != archivo) {
                    archivo.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        return texto;
    }

    public String abrirArchivo() {
        String completo = "";
        File archivo = null;
        FileReader fr = null;
        BufferedReader br = null;
        try {
            archivo = new File("texto.txt");
            fr = new FileReader(archivo);
            br = new BufferedReader(fr);
            String linea;
            while ((linea = br.readLine()) != null) {
                completo += linea + "\n";
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (null != fr) {
                    fr.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        return completo;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton abrirBtn;
    private javax.swing.JButton guardarBtn;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JButton limpiarBtn;
    private javax.swing.JButton procesarBtn;
    private javax.swing.JTextArea txt;
    private javax.swing.JTextArea txtResultado1;
    private javax.swing.JTextArea txtResultado2;
    // End of variables declaration//GEN-END:variables
}
